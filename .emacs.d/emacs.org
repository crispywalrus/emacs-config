#+TITLE: Vincent Demeester's emacs configuration
#+AUTHOR: Vincent Demeester
#+EMAIL: vincent [at] demeester [dot] fr

#+begin_src
                                                              ___ __
    .-----.--------.---.-.----.-----.______.----.-----.-----.'  _|__|.-----.
    |  -__|        |  _  |  __|__ --|______|  __|  _  |     |   _|  ||  _  |
    |_____|__|__|__|___._|____|_____|      |____|_____|__|__|__| |__||___  |
                                                                     |_____|
#+end_src

This is my first attempt to create a readable, maintainable and self
documented emacs configuration. I'm hopeful that using Org-Babel and a
literate programming style will help.

There is a lot of inspiration for this file, I'm just gonna list the
one I took the most of it :

- [[https://github.com/joodie/emacs-literal-config/blob/master/emacs.org][Joodie emacs-literal-config]]
- [[https://github.com/dakrone/dakrone-dotfiles/blob/master/.emacs.d/settings.org][Dakrone emacs configuration]]
- [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs configuration]]
- [[https://github.com/steckerhalter/steckemacs/blob/master/steckemacs.org]["Steckemacs" steckerhalter literal emacs config]]
- [[https://github.com/larstvei/dot-emacs][Lartsvei dot-emacs]]
- [[https://github.com/grettke/home/blob/master/.emacs.el][Grettke emacs configuration]]
- [[https://github.com/jkitchin/jmax][Johns customizations to maximize emacs (jmax)]]
- [[https://github.com/jwiegley/dot-emacs][jwiegley dot-emacs]]

This file is an /always/ work-in-progress, and is currently under
*heavy* modifications. The latest version of this file is always
available at my [[https://github.com/vdemeester/emacs-config][emacs-config]] github repository, the [[https://github.com/vdemeester/emacs-config/blob/master/.emacs.d/emacs.org][emacs.org]] file.

* Configuration
** How to use my configuration

   You can obtain the source by cloning this repository somewhere, but the repository
   is made to work with [[https://github.com/RichiH/vcsh][vcsh]].

   #+BEGIN_SRC sh
  vcsh clone git://github.com/vdemeester/emacs-config emacs-config
   #+END_SRC

   If you don't want to use =vcsh= but still want to have my =.emacs.d= folder
   in your =$HOME=, you could link it like that :

   #+BEGIN_SRC sh
  $ cd $HOME
  $ mkdir -p src
  $ git clone git://github.com/vdemeester/emacs-config src/vde-emacs-config
  $ ln -s src/vde-emacs-config/.emacs.d .
   #+END_SRC

*** The =init.el=

    If you just want to get the =emacs.org= file, you will have to define and setup
    some stuff for this file to work with org-babel. You could take a look to my
    [[https://github.com/vdemeester/emacs-config/blob/master/.emacs.d/init.el][init.el]] file but let's show the main stuff.

    First you will need to setup packages repository and define a =require-package=
    function, let's see what's in there (defined in =lisp/setup-package.el=).


    #+BEGIN_SRC emacs-lisp :tangle no
  (require 'package)

  ;; add org to package repos
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))

  ;; add melpa and melpa-stable to package repos
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))

  ;; If gpg cannot be found, signature checking will fail, so we
  ;; conditionnally enable it according wether gpg is availabel.
  ;; We re-run this check once $PATH has been configured
  (defun sanityinc/package-maybe-enable-signatures ()
    (setq package-check-signature (when (executable-find "gpg") 'allow-unsigned)))

  (sanityinc/package-maybe-enable-signatures)

  ;; On demand installation of packages
  (defun require-package (package &optional min-version no-refresh)
    "Install given PACKAGE, optionally requiring MIN-VERSION.
  if NO-REFRESH is non-nil, the available package lists will not be
  re-downloaded in order to locate PACKAGE."
    (if (package-installed-p package min-version)
        t
      (if (or (assoc package package-archive-contents) no-refresh)
          (package-install package)
        (progn
          (when (not package-archive-contents)
            (package-refresh-contents))
          (require-package package min-version t)))))

  ;; Fire up package.el
  (package-initialize)

  ;; install fullframe for list-packages
  (require-package 'fullframe)
  (fullframe list-packages quit-window)

  (provide 'setup-package)
    #+END_SRC

    Let's now see how I load the =emacs.org= file. In the following lines of code,
    I'm also ensuring that a recent version of [[http://orgmode.org/][org-mode]] is present on the system ;
    if not, I'm unload the current one, installing a recent one and load it.

    #+BEGIN_SRC emacs-lisp :tangle no
  ;; Support for Emacs 24 and higher only
  (let ((minver 24))
    (unless (>= emacs-major-version minver)
      (error "Your Emacs is too old -- this config requires v%s or higher" minver)))

  ;; Keep track of loading time
  (defconst emacs-start-time (current-time))

  ;; Add custom lisp files to the load-path
  (add-to-list 'load-path "~/.emacs.d/lisp")

  ;; the unload-org-mode is defined there
  (require 'vde-functions)
  ;; initialize all ELPA packages
  (require 'setup-package)

  ;; (setq package-enable-at-startup nil)
  (let ((elapsed (float-time (time-subtract (current-time)
                                             emacs-start-time))))
    (message "Loaded packages in %.3fs" elapsed))

  ;; Make sure we have a decent and recent org-mode version
  (require 'org)
  (when (string-match "^[1234567]" (org-version))
    (progn
      (warn "Org-mode is out of date. We expect org 8 or higher, but instead we have %s" (org-version))
      (warn "Force the installation from org elpa.")
      (package-install 'org)
      (unload-org-mode)
      (require 'org)
      ))

  ;; keep customize settings in their own file
  (setq custom-file
        (expand-file-name "custom.el"
                          user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file))

  ;; load the literate configuration
  (require 'ob-tangle)
  (org-babel-load-file "~/.emacs.d/emacs.org")

  (let ((elapsed (float-time (time-subtract (current-time)
                                             emacs-start-time))))
    (message "Loaded settings...done in %.3fs" elapsed))

    #+END_SRC

** Personal information

   #+begin_src emacs-lisp
     (setq user-full-name "Vincent Demeester"
           user-mail-address "vincent@demeester.fr")
   #+end_src

   Loads user settings if the file is available. I put all my personal modifications or sensitive information into this file.

   #+BEGIN_SRC emacs-lisp
  (when (file-readable-p "~/.emacs.d/user.el")
    (load "~/.emacs.d/user.el"))
   #+END_SRC

   Same will goes with host-specific files and os-specific files.


   #+BEGIN_SRC emacs-lisp
  (setq FULLHOSTNAME (format "%s" system-name))
  (setq HOSTNAME (substring (system-name) 0 (string-match "\\." (system-name))))

  (setq HOSTNAME-FILE
        (expand-file-name
         (format "hosts/%s.el" HOSTNAME)
         "~/.emacs.d"))

  (when (file-readable-p HOSTNAME-FILE)
    (load HOSTNAME-FILE))
   #+END_SRC

** General configuration
*** Appearance

    Unclutter the screen by removing menubar, toolbar and stuff, and by disabling
    the splash-screen.

    #+begin_src emacs-lisp
      (menu-bar-mode -1)
      (tool-bar-mode -1)
      (scroll-bar-mode -1)
      (setq inhibit-splash-screen t)
    #+end_src

    We want to see somewhere the column and line number, and also highlight the
    current line to see it easily.

    #+begin_src emacs-lisp
      (line-number-mode 1)
      (column-number-mode 1)
      (global-hl-line-mode 1)
    #+end_src

    Depending on the files opened and the syntax highlighting enabled, ~font-lock-mode~
    can be slow, we try to limit that, to keep Emacs reactive.

    #+begin_src emacs-lisp
      (setq font-lock-maximum-decoration 2)
    #+end_src

**** Fringe decorations

     [[http://www.emacswiki.org/emacs/TheFringe][The fringe]] is the vertical region at the right and left of the
     buffer. Emacs lets you customize it of course.

     Here I set up git diffs and buffer position in the fringe.

     #+NAME: look-and-feel
     #+BEGIN_SRC emacs-lisp
       (setq-default indicate-buffer-boundaries 'left)
       (setq-default indicate-empty-lines +1)
     #+END_SRC

**** Fonts

     I tend to install Ubuntu font family on all my computers, I like
     it :).

     #+begin_src emacs-lisp
       (set-default-font "Ubuntu Mono-12")
       (set-frame-font "Ubuntu Mono-12")
       (set-face-attribute 'default nil :family "Ubuntu Mono" :height 110)
     #+end_src

     This will set Symbola as fallback-font for Emojis when it is available for the created frame.

     #+BEGIN_SRC emacs-lisp
       (defun my-after-make-frame (frame)
         (when (find-font (font-spec :name "Symbola") frame)
           (dolist (range '((#x2600 . #x26ff)
                            (#x1f300 . #x1f5ff)
                            (#x1f600 . #x1f640)
                            (#x1f680 . #x1f6ff)))
             (set-fontset-font "fontset-default" range "Symbola"))))
       (add-to-list 'after-make-frame-functions 'my-after-make-frame)
     #+END_SRC

**** Themes

     First let's install the theme(s) and load the new theme

     #+begin_src emacs-lisp
       (use-package sublime-themes
                    :ensure t
                    :defer t)
       (use-package dakrone-theme
                    :ensure t
                    :defer t)
       (use-package leuven-theme
                    :ensure t
                    :init
                    (load-theme 'leuven))
     #+end_src

     Let's also install something to have different themes by buffers.

     #+BEGIN_SRC emacs-lisp
       ;; Temporarly deactivate this as it is bugged on MELPA
       ;; (use-package load-theme-buffer-local)
       (use-package noflet
                    :ensure t)
       (require 'load-theme-buffer-local)
     #+END_SRC

***** TODO Specific theme for modes

**** Powerline

     We are going to use [[https://github.com/milkypostman/powerline][powerline]] because it is way more sexy than the default modeline design.

     #+begin_src emacs-lisp
       (use-package powerline
                    :ensure t
                    :init
                    (powerline-default-theme))
     #+end_src
*** Behaviour

    First thing first, let's define a shortcuts for editing this configuration.


    #+BEGIN_SRC emacs-lisp
      (defun my/edit-emacs-configuration ()
        (interactive)
        (find-file "~/.emacs.d/emacs.org"))

      (global-set-key "\C-ce" 'my/edit-emacs-configuration)
    #+END_SRC


    Although I don't really care, let's add a new line at the end of files.
    Some people at work will thank me for that ;-D.

    #+begin_src emacs-lisp
      (setq require-final-newline t)
    #+end_src

    Answering yes and no to each question from Emacs can be tedious, a single y or n will suffice.

    #+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
    #+END_SRC

    Add some macros to be able to conditionnally load stuff (taken
    from [[http://emacs-fu.blogspot.fr/2008/12/using-packages-functions-only-if-they.html][emacs-fu]].


    #+BEGIN_SRC emacs-lisp
      (defmacro require-maybe (feature &optional file)
        "*Try to require FEATURE, but don't signal an error if `require' fails."
        `(require ,feature ,file 'noerror))

      (defmacro when-available (func foo)
        "*Do something if FUNCTION is available."
        `(when (fboundp ,func) ,foo))
    #+END_SRC


**** DONE Encoding

     Make sur that we use ~utf-8~ by default.

     #+begin_src emacs-lisp
       (set-terminal-coding-system 'utf-8)
       (set-keyboard-coding-system 'utf-8)
       (set-language-environment "UTF-8")
       (prefer-coding-system 'utf-8)
     #+end_src

**** DONE Mouse
     Move the mouse away to not bother.

     #+begin_src emacs-lisp
       (mouse-avoidance-mode 'jump)
     #+end_src
**** DONE Backup files

     Files suffixed with =~= in the current directory are ugly. We are still going to use
     backup files, as it can saves some time in case of trouble, but we'll move them
     somewhere else : ~/tmp/emacs-1001~ (for a user with the uid = 1001).

     Note the we store them in /tmp so in case of a reboot, we loose them.

     #+begin_src emacs-lisp
       (defconst emacs-tmp-dir (format "%s/%s%s/" temporary-file-directory "emacs" (user-uid)))
       (setq backup-directory-alist
             `((".*" . ,emacs-tmp-dir))
             auto-save-file-name-transforms
             `((".*" ,emacs-tmp-dir t))
             auto-save-list-file-prefix emacs-tmp-dir)
     #+end_src

     Now that all the temporary files are out of the way, we can keep more of them.

     #+begin_src emacs-lisp
       (setq delete-old-versions t
             kept-new-versions 6
             kept-old-versions 2
             version-control t)
     #+end_src
**** DONE Buffer names

     Setup uniquify so that non-unique buffer names get the parent path included to make them unique.

     #+begin_src emacs-lisp
       (use-package uniquify)
       (setq uniquify-buffer-name-style 'forward)
     #+end_src

**** DONE Formatting

     Use space instead on tabs for indentation by default (again some people at work
     will thank me for that).

     #+begin_src emacs-lisp
       (setq-default indent-tabs-mode nil)
     #+end_src

     Let's define a few /cleaning/ functions :

- untabify the buffer

#+begin_src emacs-lisp
  (defun my/untabify-buffer ()
    (interactive)
    (untabify (point-min) (point-max)))
#+end_src

- ident the buffer, using the mode indentation stuff

#+begin_src emacs-lisp
  (defun my/indent-buffer ()
    (interactive)
    (indent-region (point-min) (point-max)))
#+end_src

- cleanup the buffer

#+begin_src emacs-lisp
  (defun my/cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer."
    (interactive)
    (my/indent-buffer)
    (my/untabify-buffer)
    (delete-trailing-whitespace))
#+end_src

- cleanup the region

#+begin_src emacs-lisp
(defun my/cleanup-region (beg end)
  "Remove tmux artifacts from region."
  (interactive "r")
  (dolist (re '("\\\\│\·*\n" "\W*│\·*"))
    (replace-regexp re "" nil beg end)))
#+end_src

And bind =cleanup-buffer= and =cleanup-region=.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x M-t") 'my/cleanup-region)
(global-set-key (kbd "C-c n") 'my/cleanup-buffer)
#+end_src

For writing text, I prefer Emacs to do line wrapping for me.Also, superfluous
white-space should be shown.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook
            (lambda()
              (turn-on-auto-fill)
              (setq show-trailing-whitespace 't))
            )
#+END_SRC
**** DONE pretty-mode

     Pretty mode turn some stuff prettier, for example in Haskell =/== becomes =≠=, or
     =->= becomes =→=.

     #+BEGIN_SRC emacs-lisp
       (use-package pretty-mode
                    :ensure t
                    :init
                    (add-hook 'prog-mode-hook
                              'turn-on-pretty-mode))
     #+END_SRC

**** DONE raindow-identifiers

     I read an intersting article about [[https://medium.com/p/3a6db2743a1e/][how to make syntax highlighting more useful]]
     and I really like the concept. And guess what, there's a mode for that.


     #+BEGIN_SRC emacs-lisp
       (use-package rainbow-identifiers
                    :ensure t
                    :init
                    (add-hook 'prog-mode-hook
                              (lambda () (rainbow-identifiers-mode))))
     #+END_SRC
**** DONE Dired

     Dired is really a cool mode, let's enhance it.


     #+BEGIN_SRC emacs-lisp
       (setq diredp-hide-details-initially-flag nil)
       (use-package dired+
                    :ensure t
                    :init)
     #+END_SRC

**** DONE Search

     Make isearch-forward put the cursor at the start of the search, not the end, so that isearch can be used for navigation. See also http://www.emacswiki.org/emacs/IsearchOtherEnd.


     #+BEGIN_SRC emacs-lisp
  (defun my-isearch-goto-match-beginning ()
    (when (and isearch-forward (not isearch-mode-end-hook-quit)) (goto-char isearch-other-end)))
  (add-hook 'isearch-mode-end-hook 'my-isearch-goto-match-beginning)
     #+END_SRC


**** DONE Notifications
     Emacs now has notifications (freedesktop.org specifications)
     built-in. Let's load it for potential needs.

     #+BEGIN_SRC emacs-lisp
       (use-package notifications)
     #+END_SRC

     You can use it like this =\o/=.

     #+BEGIN_SRC emacs-lisp :tangle no
       (notifications-notify
           :title "You've got mail!"
           :body "There's 34 mails unread"
           :app-icon "~/.emacs.d/icons/mail.png"
           :urgency 'low)
     #+END_SRC


**** DONE Zoom(ing)

     Being able to zoom in and out can be cool, especially when
     presenting something with emacs ; so that everybody can see
     what's written.

     #+BEGIN_SRC emacs-lisp
       (global-set-key (kbd "C-+") 'text-scale-increase)
       (global-set-key (kbd "C--") 'text-scale-decrease)
     #+END_SRC

**** DONE Key maps & binding

     [[http://endlessparentheses.com/][Endless Parentheses]] is a great sourse of tips & trick on
     GNU/Emacs. Following [[http://endlessparentheses.com/the-toggle-map-and-wizardry.html][this]] and [[http://endlessparentheses.com/launcher-keymap-for-standalone-features.html][this]] articles, Let's define some
     keymaps for some quick toggling and launching.

     First, let's define a ~toogle-map~, that will allow to toggle some
     stuff like line numbers, minor modes and stuffs.

     #+BEGIN_SRC emacs-lisp
       (define-prefix-command 'vde/toggle-map)
       ;; The manual recommends C-c for user keys, but C-x t is
       ;; always free, whereas C-c t is used by some modes.
       (define-key ctl-x-map "t" 'vde/toggle-map)
       (define-key vde/toggle-map "c" #'column-number-mode)
       (define-key vde/toggle-map "d" #'toggle-debug-on-error)
       (define-key vde/toggle-map "e" #'toggle-debug-on-error)
       (define-key vde/toggle-map "f" #'auto-fill-mode)
       (define-key vde/toggle-map "l" #'toggle-truncate-lines)
       (define-key vde/toggle-map "q" #'toggle-debug-on-quit)
       (define-key vde/toggle-map "r" #'dired-toggle-read-only)
       (define-key vde/toggle-map' "w" #'whitespace-mode)
     #+END_SRC

     And now let's define a ~launcher-map~ to launch major modes and
     useful commands.

     #+BEGIN_SRC emacs-lisp
       (define-prefix-command 'vde/launcher-map)
       (define-key ctl-x-map "l" 'vde/launcher-map)
       (global-set-key (kbd "s-l") 'vde/launcher-map)
       (define-key vde/launcher-map "c" #'calc)
       (define-key vde/launcher-map "d" #'ediff-buffers)
       (define-key vde/launcher-map "f" #'find-dired)
       (define-key vde/launcher-map "g" #'lgrep)
       (define-key vde/launcher-map "G" #'rgrep)
       (define-key vde/launcher-map "h" #'man)    ; Help
       (define-key vde/launcher-map "s" #'shell)
       (define-key vde/launcher-map "t" #'proced) ; top
       (define-key vde/launcher-map "m" #'mu4e)   ; mails
       (define-key vde/launcher-map "u" #'mu4e-update-mail-and-index)
     #+END_SRC

**** TODO Evil

     I come from a [[http://vim.org][vim]] background and the modal editor comes with some
     really good stuff. [[http://www.emacswiki.org/Evil][Evil]] is an extensible vi layer for Emacs,
     exacty what we need. It also few /extensions/.

     #+BEGIN_SRC emacs-lisp
       (require-package 'evil)
     #+END_SRC

     Let's change the default cursor colours to easily identify wich
     mode we are in.

     #+BEGIN_SRC emacs-lisp
       (setq evil-emacs-state-cursor '("red" box))
       (setq evil-normal-state-cursor '("green" box))
       (setq evil-visual-state-cursor '("orange" box))
       (setq evil-insert-state-cursor '("red" bar))
       (setq evil-replace-state-cursor '("red" bar))
       (setq evil-operator-state-cursor '("red" hollow))
     #+END_SRC

     And define some /internals/.

     #+BEGIN_SRC emacs-lisp
       (setq evil-search-module 'evil-search)
     #+END_SRC

***** DONE evil-leader

      The [[https://github.com/cofi/evil-leader][evil-leader]] extension provides the <leader> feature from Vim
      that provides an easy way to bind keys under a variable prefix
      key.

      #+BEGIN_SRC emacs-lisp
        (require-package 'evil-leader)
        (global-evil-leader-mode t)

        (evil-leader/set-leader ",")
        (evil-leader/set-key
          "e" 'find-file
          "b" 'switch-to-buffer
          "k" 'kill-buffer)
      #+END_SRC

***** DONE evil-args

      The [[https://github.com/wcsmith/evil-args][evil-args]] extension provides motions and text objects for
      delimited arguments in Evil.


      #+BEGIN_SRC emacs-lisp
        (require-package 'evil-args)
        ;; bind evil-args text objects
        (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
        (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)
        ;; bind evil-forward/backward-args
        (define-key evil-normal-state-map "L" 'evil-forward-arg)
        (define-key evil-normal-state-map "H" 'evil-backward-arg)
        (define-key evil-motion-state-map "L" 'evil-forward-arg)
        (define-key evil-motion-state-map "H" 'evil-backward-arg)
        ;; bind evil-jump-out-args
        (define-key evil-normal-state-map "K" 'evil-jump-out-args)
      #+END_SRC


*** Server mode

    Start a server in not already running. I usually start emacs as a
    daemon when at the start of the computer, but you never know =;-)=.

    I have an error about /unsafe directory/ for =/tmp/emacs100=, that's
    why the advice is there, to ignore the error (from [[http://stackoverflow.com/a/17069276/89249][stackoverflow]]).

    #+BEGIN_SRC emacs-lisp
  (defadvice server-ensure-safe-dir (around
                                     my-around-server-ensure-safe-dir
                                     activate)
    "Ignores any errors raised from server-ensure-safe-dir"
    (ignore-errors ad-do-it))
  (unless (string= (user-login-name) "root")
    (require 'server)
    (when (or (not server-process)
             (not (eq (process-status server-process)
                    'listen)))
      (unless (server-running-p server-name)
        (server-start))))
    #+END_SRC

** TODO Modes
*** DONE Discover my major

    #+BEGIN_QUOTE
    Discover key bindings and their meaning for the current Emacs major mode.

    The command is inspired by discover.el and also uses the makey library. I thought, “Hey! Why not parse the information about the major mode bindings somehow and display that like discover.el does…”
    #+END_QUOTE


    #+BEGIN_SRC emacs-lisp
      (require-package 'discover-my-major)
      (global-set-key (kbd "C-h C-m") 'discover-my-major)
    #+END_SRC


*** TODO Prompts
**** DONE ido

     Ido stands for “Interactively DO things”, and even though we'll try to use Helm
     for a lot of things, ido-mode replace beautifuly the default Emacs prompt.

     #+BEGIN_QUOTE
     There are many ways of improving your productivity when you use Emacs, and Ido (or “Interactively DO things”) is one of those packages that you enable and then never, ever turn off again. It’s simply that useful. By super-charging Emacs’s completion engine and improving the speed at which you open files and buffers, you will significantly cut down on the time spent doing these menial tasks.
     #+END_QUOTE

     We're gonna enhance even more ido with some additonnal package :

- A vertical presentation for ido
#+begin_src emacs-lisp
(require-package 'ido-vertical-mode)
#+end_src
- Fuzzy matching for ido (killer-feature !)
#+begin_src emacs-lisp
(require-package 'flx)
(require-package 'flx-ido)
#+end_src
- Use ido and fuzzy matching for ~M-x~, to get first to most recent command used
#+begin_src emacs-lisp
(require-package 'smex)
#+end_src

Let's configure ido, ido-vertical-mode and flx.

#+begin_src emacs-lisp
(require 'recentf)
(setq ido-enable-flex-matching t
     ido-everywhere t
     ido-use-virtual-buffers t
     ido-use-faces nil)
(ido-mode 1)
(ido-vertical-mode 1)
(flx-ido-mode 1)
#+end_src

Let's configure smex.

#+begin_src emacs-lisp
(smex-initialize)

(global-set-key (kbd "M-x") 'smex)
(global-set-key (kbd "M-X") 'smex-major-mode-commands)
#+end_src

We bind the old ~M-x~ command to another, more complicated keys.

#+begin_src emacs-lisp
(global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
#+end_src

**** TODO helm

     #+BEGIN_QUOTE
     Helm is incremental completion and selection narrowing framework for Emacs. It will help steer you in the right direction when you’re looking for stuff in Emacs (like buffers, files, etc).

     Helm is a fork of anything.el originaly written by Tamas Patrovic and can be considered to be its successor. Helm sets out to clean up the legacy code in anything.el and provide a cleaner, leaner and more modular tool, that’s not tied in the trap of backward compatibility.
     #+END_QUOTE

     #+begin_src emacs-lisp
       (require-package 'helm)
       (require-package 'helm-descbinds)
       (require-package 'helm-gtags)
     #+end_src

     Let's define that all helm commands will be prefixed by =C-h=,
     =C-h x= will be =Helm M-x=.

     #+BEGIN_SRC emacs-lisp
       (require 'helm-config)
       (setq helm-mode-handle-completion-in-region nil) ; don't use helm for `completion-at-point'
       (helm-mode 1)
       (helm-gtags-mode 1)
       (helm-descbinds-mode)
       (setq helm-idle-delay 0.1)
       (setq helm-input-idle-delay 0.1)
       (setq helm-buffer-max-length 50)
       (setq helm-M-x-always-save-history t)
       (setq helm-buffer-details-flag nil)
       (add-to-list 'helm-completing-read-handlers-alist '(org-refile)) ; helm-mode does not do org-refile well
       (add-to-list 'helm-completing-read-handlers-alist '(org-agenda-refile)) ; same goes for org-agenda-refile
     #+END_SRC

***** DONE helm-swoop

      =helm-swoop= is a great Helm powered buffer search/occur interface:

      #+BEGIN_SRC emacs-lisp
        (require-package 'helm-swoop)
      #+END_SRC

***** DONE helm-google

      #+BEGIN_QUOTE
      Emacs Helm Interface for quick Google searches
      #+END_QUOTE

      #+BEGIN_SRC emacs-lisp
        (require-package 'helm-google)
      #+END_SRC

*** TODO Auto-complete

    #+BEGIN_QUOTE
    Auto-Complete is an intelligent auto-completion extension for
    Emacs. It extends the standard Emacs completion interface and
    provides an environment that allows users to concentrate more on
    their own work.
    #+END_QUOTE

    Install and use a basic configuration for auto-complete.

    #+BEGIN_SRC emacs-lisp
      (require-package 'auto-complete)
      (require 'auto-complete-config)
      (global-auto-complete-mode t)
      (setq ac-use-quick-help nil)
    #+END_SRC

    And setup default source & co.

    #+BEGIN_SRC emacs-lisp
      (set-default 'ac-sources
                   '(ac-source-imenu
                     ac-source-dictionary
                     ac-source-words-in-buffer
                     ac-source-words-in-same-mode-buffers
                     ac-source-words-in-all-buffer))
      (dolist (mode '(magit-log-edit-mode
                      log-edit-mode org-mode text-mode haml-mode
                      git-commit-mode
                      sass-mode yaml-mode csv-mode espresso-mode haskell-mode
                      html-mode nxml-mode sh-mode smarty-mode clojure-mode
                      lisp-mode textile-mode markdown-mode tuareg-mode
                      js3-mode css-mode less-css-mode sql-mode
                      sql-interactive-mode
                      inferior-emacs-lisp-mode))
        (add-to-list 'ac-modes mode))
    #+END_SRC


*** DONE deft

    #+BEGIN_QUOTE
    Deft is an Emacs mode for quickly browsing, filtering, and editing
    directories of plain text notes, inspired by Notational Velocity.
    #+END_QUOTE

    Deft is cool to use with org-mode, let's use it for notes.

    #+BEGIN_SRC emacs-lisp
      (require-package 'deft)

      (setq deft-extension "org")
      (setq deft-text-mode 'org-mode)
      (setq deft-directory "~/desktop/org/notes")
      (setq deft-use-filename-as-title t)         ;; Use filename as title

      (global-set-key (kbd "<f9>") 'deft)
    #+END_SRC

*** TODO Version control integration
**** TODO Git

     #+begin_src emacs-lisp
  (require-package 'git-commit-mode)
  (require-package 'git-rebase-mode)
  (require-package 'gitignore-mode)
  (require-package 'gitconfig-mode)
  (require-package 'gitattributes-mode)
     #+end_src


***** TODO magit

      #+begin_src emacs-lisp
        (require-package 'magit)
        (global-set-key "\C-cg" 'magit-status)
      #+end_src

****** DONE Magit git-svn integration

       At work, I use ~git-svn~ to be able to use git locally but integrating in the
       subversion they use. Integrating ~magit~ and ~git-svn~ is a bonus but, as it
       exists, let's do it :).

       #+begin_src emacs-lisp
(require-package 'magit-svn)
       #+end_src

       The /quick key/ to get the ~magit-svn~ menu is ~N~.
***** TODO git fringe decoration

      #+begin_src emacs-lisp
     (when (window-system)
       (require-package 'git-gutter-fringe)
       (global-git-gutter-mode +1))
      #+end_src emacs-lisp

***** DONE git-annex

      [[http://git-annex.branchable.com/][Git-annex]] is a wonderful piece of software that I use a lot in my repositories.

      #+BEGIN_QUOTE
      git-annex allows managing files with git, without checking the file contents into git. While that may seem paradoxical, it is useful when dealing with files larger than git can currently easily handle, whether due to limitations in memory, time, or disk space.
      #+END_QUOTE

      In Emacs, it integrates with magit and dired mode. The annex subcommand for magit is ~@~.

      #+begin_src emacs-lisp
(require-package 'git-annex)
(require-package 'magit-annex)
      #+end_src

***** TODO gitty
***** DONE git-timemachine
      I recently discovered an extremely cool package called git-timemachine that allows you to step though the git history of the file you’re currently editing in Emacs.

      #+BEGIN_SRC emacs-lisp
        (require-package 'git-timemachine)
      #+END_SRC


***** TODO git-blame


      #+BEGIN_SRC emacs-lisp
        (require-package 'git-blame)
      #+END_SRC


***** TODO github

      # gist, githubclone, ..
**** TODO Mercurial
*** DONE highlight-symbol

    #+BEGIN_QUOTE
    Automatic and manual symbol highlighting for Emacs
    #+END_QUOTE

    Highlights the word/symbol at point and any other occurrences in
    view. Also allows to jump to the next or previous occurrence.


    #+BEGIN_SRC emacs-lisp
  (require-package 'highlight-symbol)
  (setq highlight-symbol-on-navigation-p t)
  (add-hook 'prog-mode-hook 'highlight-symbol-mode)

  (global-set-key [(control f3)] 'highlight-symbol-at-point)
  (global-set-key [f3] 'highlight-symbol-next)
  (global-set-key [(shift f3)] 'highlight-symbol-prev)
  (global-set-key [(meta f3)] 'highlight-symbol-query-replace)
    #+END_SRC

*** DONE move-text

    Allows to move the current line or region up/down. The source code is
    on the Wiki: http://www.emacswiki.org/emacs/move-text.el

    #+BEGIN_SRC emacs-lisp
      (require-package 'move-text)
      (move-text-default-bindings)
    #+END_SRC

*** DONE multiple-cursors

    Multiple cursors for Emacs, this is a pretty /badass/ functionnality.

    #+BEGIN_SRC emacs-lisp
  (require-package 'multiple-cursors)
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
    #+END_SRC


*** TODO Flycheck

    #+BEGIN_QUOTE
    Flycheck is a modern on-the-fly syntax checking extension for GNU Emacs 24, intended as replacement for the older Flymake extension which is part of GNU Emacs.

    It uses various syntax checking and linting tools to check the contents of buffers, and reports warnings and errors directly in the buffer, or in an optional error list.
    #+END_QUOTE

    Let's install it and configure it for the common part. The language
    specifics will be defined in the corresponding language section.

    #+BEGIN_SRC emacs-lisp
  (require-package 'flycheck)
  ;; (add-hook 'prog-mode-hook 'flycheck-mode)
  (add-hook 'after-init-hook #'global-flycheck-mode)

  (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)) ;disable the annoying doc checker

  (setq flycheck-indication-mode 'right-fringe)
    #+END_SRC

*** DONE Org

    #+BEGIN_QUOTE
    Org-mode is a powerful system for organizing your complex life with simple plain-text files. It seamlessly integrates all your notes, mindmaps, TODO lists, calendar, day planner, and project schedules into a single system that can be easily searched (e.g. by grep), encrypted (e.g. by GnuPG), backed up and synced (e.g. by Dropbox), imported/exported, and accessed on the go (e.g. on an iPhone or Android smartphone). It can even be used for authoring web pages and documents.
    #+END_QUOTE

    Depending on how this section grows, org-mode might need its own litterate
    org configuration file.

**** Standard configuration

     First let's define the default directory for the =org= files, the one to be added
     to the agenda and the archives.

     #+begin_src emacs-lisp
       (require 'find-lisp)
       (setq org-directory "~/desktop/org/")
       (setq org-agenda-files (find-lisp-find-files "~/desktop/org/todos/" "\.org$"))
       (setq org-archive-location (concat org-directory "archive/%s_archive::"))
     #+end_src

     We'll also set which files should be opened using org-mode :
     =*.org=, =*.org_archive=, =*.txt=.

     #+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))
     #+end_src

     Let's also define the default /todo-keywords/ and the workflow
     between them.

- =TODO= : task not started yet, part of the backlog :)
- =PROGRESS= : task that are currently in progress, should be a minimum
- =BLOCKED= : task that I start working on but cannot anymore (for
  some reason), thus they are blocked
- =REVIEW= : task that should be done, but I need or wait for a
  review (by someone else or by me)
- =DONE= : task that are completed.
- =ARCHIVED= : same as done but keep it here (and not moving into archive)

  #+begin_src emacs-lisp
       (defface org-progress ; font-lock-warning-face
         (org-compatible-face nil
           '((((class color) (min-colors 16) (background light)) (:foreground "#A197BF" :bold t :background "#E8E6EF" :box (:line-width 1 :color "#A197BF")))
             (((class color) (min-colors 8)  (background light)) (:foreground "blue"  :bold t))
             (t (:inverse-video t :bold t))))
         "Face for PROGRESS keywords."
         :group 'org-faces)
       (defface org-cancelled ; font-lock-warning-face
         (org-compatible-face nil
           '((((class color) (min-colors 16) (background light)) (:foreground "#3D3D3D" :bold t :background "#7A7A7A" :box (:line-width 1 :color "#3D3D3D")))
             (((class color) (min-colors 8)  (background light)) (:foreground "black"  :bold t))
             (t (:inverse-video t :bold t))))
         "Face for PROGRESS keywords."
         :group 'org-faces)
       (defface org-review ; font-lock-warning-face
         (org-compatible-face nil
           '((((class color) (min-colors 16) (background light)) (:foreground "#FC9B17" :bold t :background "#FEF2C2" :box (:line-width 1 :color "#FC9B17")))
             (((class color) (min-colors 8)  (background light)) (:foreground "yellow"  :bold t))
             (t (:inverse-video t :bold t))))
         "Face for PROGRESS keywords."
         :group 'org-faces)
       (defface org-blocked ; font-lock-warning-face
         (org-compatible-face nil
           '((((class color) (min-colors 16) (background light)) (:foreground "#FF8A80" :bold t :background "#ffdad6" :box (:line-width 1 :color "#FF8A80")))
             (((class color) (min-colors 8)  (background light)) (:foreground "red"  :bold t))
             (t (:inverse-video t :bold t))))
         "Face for PROGRESS keywords."
         :group 'org-faces)

       (setq org-todo-keywords
             (quote ((sequence "TODO(t!)" "PROGRESS(p!)" "BLOCKED" "REVIEW" "|" "DONE(d!)" "ARCHIVED")
                     (sequence "REPORT(r!)" "BUG" "KNOWNCAUSE" "|" "FIXED(f!)")
                     (sequence "|" "CANCELLED(c@)"))))


       (setq org-todo-keyword-faces
             (quote (("TODO" . org-todo)
                     ("PROGRESS" . org-progress)
                     ("BLOCKED" . org-blocked)
                     ("REVIEW" . org-review)
                     ("DONE" . org-done)
                     ("ARCHIVED" . org-done)
                     ("CANCELLED" . org-cancelled)
                     ("REPORT" . org-todo)
                     ("BUG" . org-blocked)
                     ("KNOWNCAUSE" . org-review)
                     ("FIXED" . org-done))))

       (setq org-todo-state-tags-triggers
             (quote (("CANCELLED" ("CANCELLED" . t)))))
  #+end_src

  Undefine some binding (=C-c [=, =C-c ]= since this breaks org-agenda files that
  have been defined in this file (a directory).

  #+begin_src emacs-lisp
       (add-hook 'org-mode-hook
                 '(lambda ()
                    (org-defkey org-mode-map "\C-c[" 'undefined)
                    (org-defkey org-mode-map "\C-c]" 'undefined)
                    (org-defkey org-mode-map "\C-c;" 'undefined))
                 'append)
  #+end_src

  All org-mode buffers will be automatically saved each hours.

  #+BEGIN_SRC emacs-lisp
       (run-at-time "00:59" 3600 'org-save-all-org-buffers)
  #+END_SRC

  And add some miscellaneous stuff.

  #+BEGIN_SRC emacs-lisp
       (setq
        org-completion-use-ido t         ;; use IDO for completion
        org-cycle-separator-lines 0      ;; Don't show blank lines
        org-catch-invisible-edits 'error ;; don't edit invisible text
        )
  #+END_SRC

**** DONE Speed commands

     Org-mode speed keys (or spee commands) are really cool, here is a
     quotation from the manual

     #+BEGIN_QUOTE
     Single keys can be made to execute commands when the cursor is at the beginning of a headline, i.e., before the first star.
     #+END_QUOTE

     #+BEGIN_SRC emacs-lisp
       (setq org-use-speed-commands t)
     #+END_SRC

     However the default =n= (next) and =p= (previous) speed keys
     aren't optimal for my use. When I go to the next one using speed
     commands I want the others closed. Let's redefine it.

     #+BEGIN_SRC emacs-lisp
       (defun my/org-show-next-heading-tidily ()
         "Show next entry, keeping other entries closed."
         (if (save-excursion (end-of-line) (outline-invisible-p))
             (progn (org-show-entry) (show-children))
           (outline-next-heading)
           (unless (and (bolp) (org-on-heading-p))
             (org-up-heading-safe)
             (hide-subtree)
             (error "Boundary reached"))
           (org-overview)
           (org-reveal t)
           (org-show-entry)
           (show-children)))

       (defun my/org-show-previous-heading-tidily ()
         "Show previous entry, keeping other entries closed."
         (let ((pos (point)))
           (outline-previous-heading)
           (unless (and (< (point) pos) (bolp) (org-on-heading-p))
             (goto-char pos)
             (hide-subtree)
             (error "Boundary reached"))
           (org-overview)
           (org-reveal t)
           (org-show-entry)
           (show-children)))
     #+END_SRC

     And let's bind it.

     #+BEGIN_SRC emacs-lisp
       (setq org-speed-commands-user '(("n" . my/org-show-next-heading-tidily)
                                       ("p" . my/org-show-previous-heading-tidily)
                                       (":" . org-set-tags-command)
                                       ("c" . org-toggle-checkbox)
                                       ("d" . org-cut-special)
                                       ("P" . org-set-property)
                                       ("C" . org-clock-display)
                                       ("z" . (lambda () (interactive)
                                                (org-tree-to-indirect-buffer)
                                                (other-window 1)
                                                (delete-other-windows)))))
     #+END_SRC

**** DONE Captures

     First thing first, bind a key sequence to org-capture.

     #+BEGIN_SRC emacs-lisp
       (global-set-key (kbd "C-c r") 'org-capture)
     #+END_SRC

     Setup captures templates..

     #+BEGIN_SRC emacs-lisp
       (setq org-capture-templates
             '(;; other entries
               ("j" "Journal entry" plain
                (file+datetree+prompt "~/desktop/org/journal.org")
                "%K - %a\n%i\n%?\n")
               ;; other entries
               ))
     #+END_SRC

**** DONE Code blocks

     We are using a lot of code block in org-mode, in this file for example ; let's
     /fontify/ the code blocks first.

     #+begin_src emacs-lisp
(setq org-src-fontify-natively t)
     #+end_src

     Add a function to easily add a code block and bind it.

     #+begin_src emacs-lisp
       (defun my/org-insert-src-block (src-code-type)
         "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
         (interactive
          (let ((src-code-types
                 '("emacs-lisp" "python" "C" "sh" "java" "js" "clojure" "C++" "css"
                   "calc" "asymptote" "dot" "gnuplot" "ledger" "lilypond" "mscgen"
                   "octave" "oz" "plantuml" "R" "sass" "screen" "sql" "awk" "ditaa"
                   "haskell" "latex" "lisp" "matlab" "ocaml" "org" "perl" "ruby"
                   "scheme" "sqlite")))
            (list (ido-completing-read "Source code type: " src-code-types))))
         (progn
           (newline-and-indent)
           (insert (format "#+BEGIN_SRC %s\n" src-code-type))
           (newline-and-indent)
           (insert "#+END_SRC\n")
           (previous-line 2)
           (org-edit-src-code)))

       (add-hook 'org-mode-hook
                 '(lambda ()
                    (local-set-key (kbd "C-c s e") 'org-edit-src-code)
                    (local-set-key (kbd "C-c s i") 'my/org-insert-src-block))
                 'append)
     #+end_src

**** TODO Templates
**** DONE Mobile

     Define some stuff for the /org-mobile/ synchronization. The
     =org-mobile-directory= is a on a remote ssh, defined in the
     =~/.emacs.d/user.el= file (using =(setq personal-org-mobile-directory "")=).

     #+BEGIN_SRC emacs-lisp
  (require 'org-mobile)
  (setq org-mobile-directory personal-org-mobile-directory)
  (setq org-mobile-inbox-for-pull "~/desktop/org/todos/inbox.org")
  (setq org-mobile-files '("~/desktop/org/todos/"))
     #+END_SRC
**** DONE Archives

     We want to be able to archive some /done/ projects. Let's load
     org-archive and configure it.

     #+BEGIN_SRC emacs-lisp
       (require 'org-archive)
       (setq org-archive-location (concat org-directory "archive/%s_archive::"))
     #+END_SRC
**** DONE Tags

     Tags should be displayed from the 90 column.

     #+BEGIN_SRC emacs-lisp
       (setq org-tags-column -90)
     #+END_SRC

     Define a list of default tags that should apply for all org-mode
     buffers.

     #+BEGIN_SRC emacs-lisp
       (setq org-tag-alist '(
                            ("important" . ?i)
                            ("urgent" . ?u)
                            ("ongoing" . ?o)   ;; ongoing "project", use to filter big project that are on the go
                            ("@home" . ?h)     ;; needs to be done at home
                            ("@work" . ?w)     ;; needs to be done at work
                            ("@client" . ?c)   ;; needs to be done at a client place (consulting..)
                            ("dev" . ?e)       ;; this is a development task
                            ("infra" . ?a)     ;; this is a sysadmin/infra task
                            ("document" . ?d)  ;; needs to produce a document (article, post, ..)
                            ("download" . ?D)  ;; needs to download something
                            ("media" . ?m)     ;; this is a media (something to watch, listen, record, ..)
                            ("mail" . ?M)      ;; mail-related (to write & send or to read)
                            ))
     #+END_SRC

     Note that =important= and =urgent= helps me prioritize my
     /todos/, in a /quadrant fashion way/.

     | Important          | *Kaizen*        | *Panic*             |
     | /tag important/    | improvements    | emergency           |
     |--------------------+-----------------+---------------------|
     | Less Important     | *Organics*      | Social *investment* |
     | /no tag important/ | inspiration     | Social activities   |
     |--------------------+-----------------+---------------------|
     |                    | Less Urgent     | Urgent              |
     |                    | /no tag urgent/ | /tag urgent/        |


**** TODO Time tracking & Pomodoros
**** DONE Agenda(s)

     First thing first, bind a key sequence to org-agenda.

     #+BEGIN_SRC emacs-lisp
       (global-set-key (kbd "C-c a") 'org-agenda)
     #+END_SRC

     Then set custom agendas.. For the syntax, look in worg : [[http://orgmode.org/worg/org-tutorials/advanced-searching.html][Advanced
     searching]] and [[http://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html][Custom Agenda Commands]].

     #+BEGIN_SRC emacs-lisp
       (setq org-agenda-custom-commands
             '(("w" todo "TODO"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ("p" todo "PROGRESS"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ("r" todo "REVIEW"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ("b" todo "BLOCKED"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ;; Panic tasks : urgent & important
               ;; Probably the most important to do, but try not have to much of them..
               ("P" . "Panic -emergency-")
               ("Pt" "TODOs" tags-todo "important&urgent/!TODO"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ("Pb" "BLOCKEDs" tags-todo "important&urgent/!BLOCKED"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ("Pr" "REVIEWs" tags-todo "important&urgent/!REVIEW"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ;; Kaizen tasks : important but not urgent
               ("K" . "Kaizen -improvement-")
               ("Kt" "TODOs" tags-todo "important&-urgent/!TODO"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ("Kb" "BLOCKEDs" tags-todo "important&-urgent/!BLOCKED"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ("Kr" "REVIEWs" tags-todo "important&-urgent/!REVIEW"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ;; Social investment : urgent
               ("S" . "Social -investment-")
               ("St" "TODOs" tags-todo "-important&urgent/!TODO"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ("Sb" "BLOCKEDs" tags-todo "-important&urgent/!BLOCKED"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ("Sr" "REVIEWs" tags-todo "-important&urgent/!REVIEW"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ;; Organics
               ("O" . "Organics -inspiration-")
               ("Ot" "TODOs" tags-todo "-important&-urgent/!TODO"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ("Ob" "BLOCKEDs" tags-todo "-important&-urgent/!BLOCKED"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
               ("Or" "REVIEWs" tags-todo "-important&-urgent/!REVIEW"
                ((org-agenda-sorting-strategy '(priority-down))
                 (org-agenda-prefix-format "  Mixed: ")))
             ("N" search ""
              ((org-agenda-files '("~org/notes.org"))
               (org-agenda-text-search-extra-files nil)))))
     #+END_SRC

**** TODO Integration with git
***** TODO Auto-commit when pushing with org-mobile
***** TODO Notifications
**** TODO Externals (caldav, issues, ..)
***** TODO Redmine

      On some project (mainly @work), redmine is used. As I'm using
      org-mode for tracking the stuff I do and the time I spent on it,
      let's integrate org-mode and redmine.

      #+BEGIN_SRC emacs-lisp
        (require-package 'org-redmine)
      #+END_SRC

      The uri of the redmine(s) will be specified in a org-babel
      matter in the org files that need it. Still have to define a
      default template.
***** DONE Trello

      On some project, [[https://trello.com/][Trello]] is used and, there a emacs package for
      that :).

      #+BEGIN_SRC emacs-lisp
        (require-package 'org-trello)
      #+END_SRC

      Now, a /manual/ step will be to install consumer key and stuff
      (see [[https://org-trello.github.io/trello-setup.html][documentation]] for that).

*** TODO Projectile

    #+BEGIN_QUOTE
    Projectile is a project interaction library for Emacs. Its goal is
    to provide a nice set of features operating on a project level
    without introducing external dependencies(when feasible). For
    instance - finding project files has a portable implementation
    written in pure Emacs Lisp without the use of GNU find (but for
    performance sake an indexing mechanism backed by external commands
    exists as well).
    #+END_QUOTE


    #+BEGIN_SRC emacs-lisp
      (require-package 'projectile)
      ;; Integrate with helm
      (require-package 'helm-projectile)
    #+END_SRC


    #+BEGIN_SRC emacs-lisp
      (projectile-global-mode)
    #+END_SRC

**** Perspective

     [[https://github.com/nex3/perspective-el][Perspective]] is a minor mode that provides the ability to manage
     different workspaces. It integrates well with projectile.

     #+BEGIN_SRC emacs-lisp
      (require-package 'perspective)
      (require-package 'persp-projectile)
     #+END_SRC

     Let's configure it and map it.

     #+BEGIN_SRC emacs-lisp
      (persp-mode)
      (require 'persp-projectile)
      (define-key projectile-mode-map (kbd "s-s") 'projectile-persp-switch-project)
     #+END_SRC


*** DONE Compilation mode improvements

    See http://stackoverflow.com/questions/3072648/cucumbers-ansi-colors-messing-up-emacs-compilation-buffer


    #+BEGIN_SRC emacs-lisp
  (require 'ansi-color)
  (defun my/colorize-compilation-buffer ()
    (toggle-read-only)
    (ansi-color-apply-on-region (point-min) (point-max))
    (toggle-read-only))
  (add-hook 'compilation-filter-hook 'my/colorize-compilation-buffer)
    #+END_SRC

    And let's configure the compilation-mode to follow the compilation, not waiting
    at the top..


    #+BEGIN_SRC emacs-lisp
  (setq compilation-scroll-output t)
    #+END_SRC

*** TODO Lua

    #+BEGIN_SRC emacs-lisp
      (require-package 'lua-mode)
    #+END_SRC

*** TODO Haskell

    #+begin_src emacs-lisp
(require-package 'haskell-mode)
(require-package 'ghc)
(require-package 'ghci-completion)
(require-package 'shm)
    #+end_src

**** DONE Flycheck

     #+BEGIN_SRC emacs-lisp
       (require-package 'flycheck-haskell)
       (eval-after-load 'flycheck
         '(add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))
     #+END_SRC

*** TODO Lisp(s)
**** TODO General

     Let's install some LISP common useful modes.

     #+BEGIN_SRC emacs-lisp
  (require-package 'paredit)
  (require-package 'rainbow-mode)
  (require-package 'rainbow-delimiters)
  (require-package 'highlight-parentheses)
     #+END_SRC

     And define a comme lisp hook for all LISP-related prog-modes, mostly about
     parentheses.

     #+BEGIN_SRC emacs-lisp
       (defun my/lisps-mode-hook ()
         (paredit-mode t)
         (rainbow-delimiters-mode t)
         (highlight-parentheses-mode t)
         )
     #+END_SRC

**** TODO Emacs lisp


     #+BEGIN_SRC emacs-lisp
       (add-hook 'emacs-lisp-mode-hook
                 (lambda ()
                   (my/lisps-mode-hook)
                   (eldoc-mode 1))
                 )
     #+END_SRC

**** TODO Clojure

     #+BEGIN_SRC emacs-lisp
       (require-package 'clojure-mode)
     #+END_SRC


     #+BEGIN_SRC emacs-lisp
       (add-hook 'clojure-mode-hook 'my/lisps-mode-hook)
     #+END_SRC


***** TODO cider

      #+BEGIN_SRC emacs-lisp
        (require-package 'cider)
      #+END_SRC

*** TODO Java

*** TODO Python

*** TODO Ruby

    I don't really use [[https://www.ruby-lang.org/][Ruby]] that much but when I need to work on a Ruby project
    I want to have a decent configuration.

    Tell Emacs rake, bundler files and =*.erb= are Ruby files.

    #+BEGIN_SRC emacs-lisp
  (dolist (exp '("Rakefile\\'" "\\.rake\\'" "Gemfile\\'" "\\.erb\\'"))
    (add-to-list 'auto-mode-alist
                 (cons exp 'ruby-mode)))
    #+END_SRC

*** Compilation mode

    Let's use a local theme for the shells.

    #+BEGIN_SRC emacs-lisp
       (defun my/compilation-theme-hook ()
         (load-theme-buffer-local 'wombat))
       (add-to-list 'compilation-mode-hook 'my/compilation-theme-hook t)
    #+END_SRC

*** TODO Shell(s)

*** TODO Go

*** PROGRESS SQL

    Emacs is really more than an editor. The SQL mode is quick cool to
    used (and do not eat my memory like mysql-workbench for
    example).

    By default, Emacs does not automatically truncate long lines in
    SQL(i) mode, let's change that.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'sql-interactive-mode-hook
                (lambda ()
                  (toggle-truncate-lines t)))
    #+END_SRC

*** TODO Docker

*** TODO fic-mode
*** TODO Linux related modes
**** TODO Archlinux
     I'm using [[http://archlinux.org][Archlinux]] on my personnal computers and I maintain a few packages
     on [[https://aur.archlinux.org][aur]], hopefully there is a mode for that.

     #+BEGIN_SRC emacs-lisp
       (require-package 'pkgbuild-mode)
     #+END_SRC

**** TODO Debian
*** DONE Markdown

    #+BEGIN_SRC emacs-lisp
      (require-package 'markdown-mode)
      (require-package 'markdown-mode+)
    #+END_SRC


*** DONE Yaml

    #+BEGIN_SRC emacs-lisp
      (require-package 'yaml-mode)
    #+END_SRC

*** TODO Ansible

    [[http://docs.ansible.com/index.html][Ansible]] is a great automation tool I use to manage my servers and
    desktops.

    #+BEGIN_SRC emacs-lisp
  (require-package 'ansible)
  (add-hook 'yaml-mode-hook '(lambda () (ansible 1)))
    #+END_SRC

    The following snippet is taken from [[http://www.lunaryorn.com/2014/07/18/ansible-docs-in-emacs.html][lunaryorn article]] about getting
    ansible doc in emacs.

    #+BEGIN_SRC emacs-lisp
  (defconst lunaryorn-ansible-doc-buffer " *Ansible Doc*"
    "The Ansible Doc buffer.")

  (defvar lunaryorn-ansible-modules nil
    "List of all known Ansible modules.")

  (defun lunaryorn-ansible-modules ()
    "Get a list of all known Ansible modules."
    (unless lunaryorn-ansible-modules
      (let ((lines (ignore-errors (process-lines "ansible-doc" "--list")))
            modules)
        (dolist (line lines)
          (push (car (split-string line (rx (one-or-more space)))) modules))
        (setq lunaryorn-ansible-modules (sort modules #'string<))))
    lunaryorn-ansible-modules)

  (defun lunaryorn-ansible-doc (module)
    "Show ansible doc for MODULE."
    (interactive
     (list (ido-completing-read "Ansible Module: "
                                (lunaryorn-ansible-modules)
                                nil nil nil nil nil
                                (thing-at-point 'symbol 'no-properties))))
    (let ((buffer (get-buffer-create lunaryorn-ansible-doc-buffer)))
      (with-current-buffer buffer
        (setq buffer-read-only t)
        (view-mode)
        (let ((inhibit-read-only t))
          (erase-buffer)
          (call-process "ansible-doc" nil t t module))
        (goto-char (point-min)))
      (display-buffer buffer)))
    #+END_SRC

    Let's bind it.

    #+BEGIN_SRC emacs-lisp
  (eval-after-load 'yaml-mode
    '(define-key yaml-mode-map (kbd "C-c h a") 'lunaryorn-ansible-doc))
    #+END_SRC

*** DONE vim

    I tend to use vim for quick edit and other stuff and have a decent
    configuration. And sometimes I edit the configuration, from emacs so, let's
    had support for that.

    #+BEGIN_SRC emacs-lisp
    (require-package 'vimrc-mode)
    #+END_SRC

*** TODO Spellcheck (flyspell)
*** Clean the modeline

    With all the modes (major & minor), the modeline becomes really
    big and unusable ; let's clean it.


    #+BEGIN_SRC emacs-lisp
      (defvar mode-line-cleaner-alist
        `((auto-complete-mode       . " α")
          (yas-minor-mode           . " γ")
          (paredit-mode             . " Φ")
          (eldoc-mode               . "")
          (abbrev-mode              . "")
          (undo-tree-mode           . " τ")
          (volatile-highlights-mode . " υ")
          (elisp-slime-nav-mode     . " δ")
          (nrepl-mode               . " ηζ")
          (nrepl-interaction-mode   . " ηζ")
          (cider-mode               . " ηζ")
          (cider-interaction        . " ηζ")
          (undo-tree-mode           . "")
          (projectile-mode          . "")
          (helm-mode                . "")
          ;; Major modes
          (clojure-mode             . "λ")
          (hi-lock-mode             . "")
          (python-mode              . "Py")
          (emacs-lisp-mode          . "EL")
          (markdown-mode            . "md")
          (magit                    . "ma")
          (haskell-mode             . "ha")
          (tuareg-mode              . "ml")
          (flymake-mode             . "fm"))
        "Alist for `clean-mode-line'.

      When you add a new element to the alist, keep in mind that you
      must pass the correct minor/major mode symbol and a string you
      want to use in the modeline *in lieu of* the original.")

      (defun clean-mode-line ()
        (interactive)
        (loop for cleaner in mode-line-cleaner-alist
              do (let* ((mode (car cleaner))
                        (mode-str (cdr cleaner))
                        (old-mode-str (cdr (assq mode minor-mode-alist))))
                   (when old-mode-str
                     (setcar old-mode-str mode-str))
                   ;; major mode
                   (when (eq mode major-mode)
                     (setq mode-name mode-str)))))


      (add-hook 'after-change-major-mode-hook 'clean-mode-line)


      ;;; Greek letters - C-u C-\ greek ;; C-\ to revert to default
      ;;; ς ε ρ τ υ θ ι ο π α σ δ φ γ η ξ κ λ ζ χ ψ ω β ν μ
    #+END_SRC

** TODO Mails

   Add mu4e to the load-path and load it.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
     (require-maybe 'mu4e)
   #+END_SRC

   Let's /detect/ if mu is installed as mu-git or mu. It's a
   workaround I need to use because of the name conflict between mu
   and the mails-utils mu command.

   #+BEGIN_SRC emacs-lisp
     ;; (setq mu4e-mu-binary "/usr/local/bin/mu")
   #+END_SRC

   Set the maildir, folders and stuff.

   #+BEGIN_SRC emacs-lisp
     (setq mu4e-maildir (expand-file-name "~/desktop/mails"))
     (setq mu4e-drafts-folder "/main/Drafts")
     (setq mu4e-sent-folder   "/main/Sent")
     (setq mu4e-trash-folder  "/main/Trash")

     (setq mu4e-get-mail-command "offlineimap")
     (setq mu4e-html2text-command "html2text")
   #+END_SRC


   #+BEGIN_SRC emacs-lisp
     (setq message-send-mail-function 'message-send-mail-with-sendmail
           sendmail-program "/usr/bin/msmtp"
           user-full-name "Vincent Demeester")
   #+END_SRC


   #+BEGIN_SRC emacs-lisp
     (add-to-list 'mu4e-view-actions '("retag" . mu4e-action-retag-message))
     (add-to-list 'mu4e-headers-actions '("retag" . mu4e-action-retag-message))
   #+END_SRC


** TODO Twitter

   Let's have a twitter timeline in Emacs, just for fun ;-P.


   #+BEGIN_SRC emacs-lisp
     (require-package 'twittering-mode)
   #+END_SRC
